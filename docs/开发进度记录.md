# 开发进度记录

## 项目信息
- **项目名称**: Tauri HTTP Wrapper (Custom Auth)
- **目标**: 使用 Tauri 2.0 封装 `http://test-otc.68chat.co/`，并拦截所有 API 请求添加自定义验证头，防止直接浏览器访问。
- **启动时间**: 2025-11-24

## 开发日志

### 2025-11-24: 项目初始化与方案设计
- [x] 创建项目目录结构
- [x] 初始化 Tauri 2.0 配置 (`tauri.conf.json`)
- [x] 实现 JS 注入脚本 (拦截 Fetch/XHR)
- [x] 实现 Rust 后端代理逻辑 (Reqwest + 加密/Header)
- [x] 配置权限 (Capabilities)
- [x] 修复 build.rs 编译错误
- [x] 创建占位图标文件并解决图标加载问题
- [x] 验证 Tauri 项目编译与运行成功
- [x] 实现设备指纹功能（UUID + 硬件哈希）
- [x] 实现 RSA 非对称加密验证（公钥加密，私钥解密）
- [x] 设计并生成应用图标（章鱼 + 盾牌安全主题）
- [x] 优化图标为圆形无白边设计
- [x] 修复 JS 注入时机问题（先注入脚本，后加载 URL）

### 技术验证结果
- **编译**: ✅ 成功（使用 npx @tauri-apps/cli@2）
- **启动**: ✅ 成功（应用窗口已打开）
- **URL加载**: ✅ 成功（正在加载 http://test-otc.68chat.co/）
- **JS注入**: 待用户验证（打开开发者工具查看控制台日志）
- **设备指纹**: ✅ 已实现并自动添加到请求头
- **RSA加密**: ✅ 已实现，签名已加密

### 安全加固：RSA 非对称加密
**实现位置**: `src-tauri/src/crypto.rs`

**加密流程**:
1. 客户端生成签名数据：`timestamp|fingerprint|url_hash`
2. 使用内置 RSA 公钥加密签名数据
3. 将加密后的 Base64 字符串添加到请求头 `X-Client-Signature`

**验证流程**（Java 后端）:
1. 读取 `X-Client-Signature` 头
2. 使用 RSA 私钥解密签名数据
3. 验证时间戳（防重放攻击）
4. 验证设备指纹是否匹配
5. 可选：验证 URL 哈希

**密钥文件**:
- 公钥：已嵌入应用 (`src-tauri/src/crypto.rs`)
- 私钥：`private_key.pem`（⚠️ 仅用于服务端，已加入 .gitignore）

**Java 后端集成指南**: 详见 `KEYS_README.md`

### 请求头说明
| Header 名称 | 值示例 | 说明 |
|------------|--------|------|
| X-Client-Signature | `aGVsbG8gd29ybGQ...` | RSA 加密的签名（Base64） |
| X-Timestamp | `2025-11-24T14:00:00Z` | ISO8601 时间戳 |
| X-Device-Fingerprint | `550e8400-...` | 设备唯一指纹 |

## Java 后端集成完成

### 已完成的工作
- ✅ 生成 PKCS#8 格式私钥（Java 兼容）
- ✅ 复制私钥文件到 Java 项目 (`src/main/resources/private_key.pem`)
- ✅ 实现 `SafeVerifyInterceptor` 拦截器（完整的 RSA 解密验证逻辑）
- ✅ 拦截器已注册到 `WebConfig`（拦截所有请求）
- ✅ 更新 Rust 客户端公钥（与新私钥配对）

### 验证逻辑
1. 检查请求头是否包含 `X-Client-Signature`、`X-Timestamp`、`X-Device-Fingerprint`
2. 使用 RSA 私钥解密签名
3. 验证时间戳（防重放攻击，允许5分钟误差）
4. 验证设备指纹是否匹配
5. 验证 URL 哈希是否匹配

### 安全策略
- **拒绝策略**: 没有正确签名的请求返回 `403 Forbidden`
- **时间窗口**: 请求时间戳必须在 ±5 分钟内
- **日志记录**: 所有验证失败的请求会被记录（包含 IP 和指纹）

### 可选扩展（已预留代码）
在 `SafeVerifyInterceptor` 中搜索注释 `// 可选：检查设备指纹白名单`，可以添加数据库查询逻辑：
```java
if (!isDeviceWhitelisted(fingerprint)) {
    log.warn("Device not whitelisted: {}", fingerprint);
    return false;
}
```

## 架构说明
1. **拦截层 (`src/inject.js`)**:
   - 重写 `window.fetch` 和 `XMLHttpRequest`。
   - 将请求转发给 Tauri Command `proxy_request`。
2. **代理层 (`src-tauri/src/proxy.rs`)**:
   - 接收前端请求。
   - 添加 `X-Client-Verify` 头。
   - 维护 Cookie Jar (确保登录态)。
   - 转发请求至 Java 后端。
3. **配置层**:
   - `tauri.conf.json`: 开启 `withGlobalTauri`，指向远程 URL。
   - `capabilities/default.json`: 允许 IPC 通信。

### 2025-11-25: 修复打包环境跳转与权限问题
- [x] 修复环境变量缓存问题：修改 `build.rs` 添加 `cargo:rerun-if-env-changed` 指令，确保切换环境时强制重新编译。
- [x] 修复生产环境权限缺失：在 `tauri.conf.json` 中显式添加 `capabilities: ["default"]`，解决代理拦截失效问题。
- [x] 优化启动流程：移除不稳定的 `index.html` 跳转逻辑，改为在 `lib.rs` 中直接使用 `WebviewUrl::External` 加载目标地址，提升启动速度和稳定性。
- [x] 修复编译警告：移除未使用的 `devtools` cfg 检查。

### 2025-11-25 (PM): 开启生产环境调试以排查白屏问题
- [x] 在 `Cargo.toml` 中临时启用 `devtools` feature，确保打包版本也可以打开控制台。
- [x] 在 `lib.rs` 中强制设置 `DEVTOOLS_ENABLED = true`，允许生产环境使用右键检查或自动打开调试窗口。

### 2025-11-25 (PM2): 修复白屏问题 - 回退到本地跳转方案
- [x] 发现直接 `WebviewUrl::External` 加载远程 HTTPS 地址会被 macOS/Tauri 视为不安全并阻止（显示 `about:blank`）。
- [x] 创建 `dist/index.html`：作为本地启动页，包含自动跳转 JS 逻辑。
- [x] 修改 `lib.rs`：将 `initialization_script` 改为注入 `window.TARGET_URL`，然后加载本地 `index.html`。
- [x] 实现原理：`index.html` (本地) -> 读取注入的 `TARGET_URL` -> `window.location.replace` -> 目标网站。此方式可完美绕过加载拦截，且保证 JS 注入成功。

### 2025-11-25 (PM3): 解决 CSP 拦截跳转问题 - 使用 Rust 代理跳转
- [x] 发现单纯的 JS `location.replace` 在 Tauri 2.0 本地特权页面中仍被沙箱拦截。
- [x] **最终方案**: 实现 `navigate_to_target` Rust Command。
- [x] 前端 (`index.html`)：加载完成后调用 `invoke('navigate_to_target')`。
- [x] 后端 (`lib.rs`)：接收指令后，在 Rust 进程中使用 `window.eval("window.location.replace(...)")` 强制执行跳转。
- [x] 原理：Rust 主进程拥有最高权限，不受 Webview 沙箱 CSP 限制，可强制将页面重定向到任意 URL。

### 2025-11-25 (PM4): 修复 Rust 跳转逻辑
- [x] 发现 Tauri v2 的 `eval` 导航仍然受限，改用 Host 级 API `window.navigate(url)`。
- [x] **自动化流程**: 移除前端手动调用 `invoke`，改为 Rust `setup` 钩子中自动 spawn 线程，延迟 800ms 后执行 `navigate`。
- [x] 这种方式彻底解耦了前端 JS 环境，即使前端报错或未初始化，Rust 也能强制 Webview 跳转。

### 2025-11-25 (PM5): 最终问题定位 - macOS ATS 策略
- [x] 经过多轮调试，发现所有代码逻辑都是正确的，Tauri 2.0 也是正常的。
- [x] **根因**: 目标服务器是 HTTP 协议，打包后的 macOS App 被系统 ATS (App Transport Security) 强制拦截，导致页面加载静默失败。
- [x] **验证**: 将目标 URL 临时改为 `https://www.baidu.com` 后，应用瞬间正常跳转，无任何报错。
- [x] **解决方案**: 采用方案 A（服务端升级 HTTPS），并移除了所有绕路的跳转代码，回归最简洁的 `WebviewUrl::External` 直接加载模式。
- [x] **代码清理**: 删除了 `dist/index.html`、移除了 `url` crate、清理了 `lib.rs` 中的复杂跳转逻辑。


